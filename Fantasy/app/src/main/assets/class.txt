class BattleManager{
enum BATTLE_STATE{
        complete,		//�ꏄ����
        effect,			//�G�t�F�N�g�`�撆
        turn_end,		//�s���A�G�t�F�N�g�`��I��
    }

    protected Attackable[] list;
    protected Attackable[] enemyList;
    protected BattleStateEnum battleStateEnum = BattleStateEnum.All_Start;
    protected int turnIndex = 0;
    protected BattleAction battleAction;
    protected Attackable actor;

    BATTLE_STATE state; //�Q�[�����̏��

    public BattleManager(EnemyTemplate[] enemys){
        //�G�y�уv���C���[���܂ރ��X�g�ƁA�G�݂̂̃��X�g��������
        enemyList = new Attackable[enemys.length];
        list = new Attackable[enemys.length+1];
        for(int n = 0;n < enemyList.length;n++){
            float ox = GLES20Util.getWidth_gl()/(float)(enemyList.length+1) * (float)(n+1);
            float oy = GLES20Util.getHeight_gl()/3f*2f;
            enemyList[n] = new Battle.Enemy(enemys[n],ox,oy);
            list[n] = enemyList[n];
        }
        //���X�g�̈�ԍŌ�Ƀv���C���[��}��
        list[list.length-1] = new Player(GameManager.getPlayerData());
        battleAction = new BattleAction();
    }

	public BattleAction getBattleAction(){
		return battleAction;
	}

    public Attackable[] getEnemyList(){
        return enemyList;
    }

    public void proc(){
        if(turnIndex >= list.length){
            //�����C���f�b�N�X�����X�g�𒴂����ꍇ�͈ꏄ�����Ƃ݂Ȃ�
            turnIndex = 0;
            state = BATTLE_STATE.complete;
        }

        if(state == BATTLE_STATE.complete){
            //�G�̃��X�g���\�[�g
            Arrays.sort(list);
            actor = list[0];
            state = BATTLE_STATE.turn_end;
        }else if(state == BATTLE_STATE.turn_end){	//�V���ȃ^�[���J�n
            //�s�����ׂ��L�����N�^�[��I��
            actor = list[turnIndex];
        	
			//�s���I��
        	actor.action(battleAction);
        	
			if(!battleAction.isEnd()){	//�I�𒆂Ȃ�true���Ԃ�
	            //�I���I��
	            state = BATTLE_STATE.effect;	//��Ԃ��G�t�F�N�g�\����Ԃ�
	            //effectDrawer.init();			//�G�t�F�N�g�̕\����������
	            turnIndex++;	//���̃L�����N�^�[���s���ł���悤�ɃC���f�b�N�X���C���N�������g
	            return;
        	}
	    }else if(state == BATTLE_STATE.effect){
	        //�G�t�F�N�g�`�撆�͑�����󂯕t���Ȃ�
	    }
    }

	public void draw(float offset_x,float offset_y){
		if(state == BATTLE_STATE.effect){
			//�G�t�F�N�g�̕\��
			float ox = battleAction.target.getX();
			float oy = battleAction.target.getY();
			float sx = Constant.enemy_damage_size_x;
			float sy = Constant.enemy_damage_size_y;
			if(battleAction.target.getAttacerType() == Attackable.AttackerType.Friend){
				//�s���Ώۂ��v���C���[�Ȃ�ʒu�𒆐S�A�T�C�Y���{
				ox = GLES20Util.getWidth_gl / 2f;
				oy = GLES20Util.getHeight_gl / 2f;
				sx = Constant.friend_damage_size_x;
				sy = Constant.friend_damage_size_y;
			}

			if(battleAction.drawEffect(ox,oy,sx,sy,0)){
				state == BATTLE_STATE.turn_end;
			}
		}
	}
}

abstract class Attackable{
	public enum AttackerType{
		Battle.Enemy,
		Friend
	}
	protected int hp;
	protected int atk;
	protected int def;
	protected int agl;
	protected int mp;
	
	public int getHp();
	public int getAtk();
	public int getDef();
	public int getAgl();
	public int getMp();
	public void action(BattleManager bm);


}

class Battle.Enemy extends Attackable{
	protected Skill[] skills;
	public Battle.Enemy(EnemyTemplate et){
		hp = et.hp;
		atk = et.atk;
		def = et.def;
		agl = et.agl;
		mp = et.mp;
		skills = et.skills;
	}

	public void action(BattleManager bm){
		BattleAction action = bm.getBattleAction();
	}

	
}

class BattleAction{
	public Attackable owner;
    public Attackable target;
	public ActionType type;
    public Skill skill;
    public int id;
    protected int damage;
    protected boolean isEnd = false;

    public boolean isEnd(){
        return isEnd;
    }

    public void resetInfo(){
        isEnd = false;
    }
	public boolean drawEffect(float ox,float oy,float sx,float sy,float deg){
		if(type == AttackType.Skill){
			return skill.draw(ox,oy,sx,sy,deg);
		}else if(type == AttackType.Normal){
			return //�ʏ�U���̕\��
		}else{
			return //�A�C�e���̕\��
		}
	}
}

abstract class Skill{
	protected String skillName;
	protected Animator animator;
	protected float timeBuffer;

	public void effectInit(){
		animator.init();
		timeBuffer = 0;
	}
	public boolean draw(float ox,float oy,float sx,float sy,float deg{
		if(timeBuffer >= Constant.skill_effect_time){
			return true;	//�I�������true
		}

		int temp = (int)((float)animator.getAnimationNum() / Constant.skill_effect_time * timeBuffer);
		Bitmap bitmap = animator.getBitmap(temp)

		GLES20Util.DrawGraph(ox,oy,sx,sy,bitmap,ALPHA);

		timeBuffer += Time.getDeltaTime();
		return false
	}

}
